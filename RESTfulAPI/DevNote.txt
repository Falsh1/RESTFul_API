2025-10-21

代码运行服务器选择：1.IIS(只能在Windows上运行)  2.RESTfulAPI(KESTREL服务器)
app.Environment.IsDevelopment() 解决方案的属性-调试-环境变量（修改不同的开发版本）

MVC结构代码：

1.添加控制器
//注册控制器服务
builder.Services.AddControllers(); 
//映射控制器路由
app.MapControllers();

起名规范：xxxController 或 继承ControllerBase 或 [ApiController]

2025-10-22
docker创建：
1.拉取sqlserver容器化镜像： docker pull mcr.microsoft.com/mssql/server:2022-latest
2.查看镜像  docker images
3.运行镜像（强密码类型）  docker run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=Zhaowenyao@123" -p 1433:1433 -d mcr.microsoft.com/mssql/server:2022-latest
4.检查正在运行的镜像 docker ps 
5.排查未运行成功的原因 docker ps -a(查看历史记录，获取ID),docker logs + ID

2025-10-27
AppDbContext 注册数据库上下文服务
依赖注入类型：
Transient  每次注入都新new
Scoped     同一个HTTP请求内只new一次
Singleton  整个进程只new一次

2025-10-28
使用Docker创建数据库

2025-10-30
通过代码Models模型来自动创建数据库  Microsoft.EntityFrameworkCore.Tools
1.打开Package Manager Console(程序包管理控制器)
2.启动Docker
3.输入命令：add-migration initialMigration  （initialMigration为本次创建的数据库名称）
4.update-database

重写上下文AppDbContext的OnModelCreating方法,读取Json文件来配置实体类和数据库表的映射关系

2025-11-03
更新数据库
修改Model类，更新数据库

RESTFul接口风格：用 URL 定位资源，用 HTTP 动词描述动作，用 HTTP 状态码表达结果，无状态地返回统一格式的表述

| 1. 资源导向		| URL 里只有名词，且用复数集合      | `/orders` 订单集合 `/orders/123` 单个订单					| （非RestFul风格）`/getOrder?id=123` <br> `/createOrder` |
| 2. 动词归 HTTP	| 动作由 HTTP 方法给出				| GET 查 POST 增 PUT 全量更新 PATCH 差量更新 DELETE 删		| （非RestFul风格）POST /getOrder <br> POST /deleteOrder  |
| 3. 无状态			| 服务器不存“上一次”的上下文      | 鉴权把 JWT 放 Header，每次请求自带完整信息                | （非RestFul风格）依赖服务端 Session，先 POST /login 才能调别的接口    |
| 4. 统一接口		| 同资源同一套 URL，不同方法        | 对 `/orders/123` 用 GET/PUT/PATCH/DELETE 即可				| （非RestFul风格）为每种操作都新建一个 URL                         |
| 5. 状态码表意		| 用标准码告诉客户端结果            | 201 创建成功 204 删除成功 404 资源不存在 409 业务冲突     | （非RestFul风格）200 里包 `{success:false,msg:"出错啦"}`     |
| 6. 可缓存&分层	| 利用 HTTP 缓存头、代理、CDN 加速  | GET /orders 返回 `Cache-Control: max-age=30`				| （非RestFul风格）所有响应都 `no-store`，放弃缓存优势                |
| 7. HATEOAS（超媒体驱动）|返回体里带链接，告诉客户端“下一步可以去哪” |  例：下单成功后返回 { links: { payment: "/orders/123/pay" } }

HTTP状态码：1xx 信息性状态码 2xx 成功状态码 3xx 重定向状态码 4xx 客户端错误状态码 5xx 服务端错误状态码
200 OK 
201 创建成功
204 处理成功，不需要内容

2025-11-04
接口请求内容协商：Accept: application/json  application/xml	
builder.Services.AddControllers(setupAction =>
{
    setupAction.ReturnHttpNotAcceptable = true;//设置返回406状态码,当请求的格式不被支持时
}).AddXmlDataContractSerializerFormatters();//添加XML格式支持

DTO模型映射（AutoMapper,profile文件）

父子资源的嵌套映射 Include(表连接) 
映射的字段一致，且是Profile文件中配置的对象
_appDbContext.TouristRoutes.Include(p => p.TouristRoutePictures)

2025-11-05
API请求参数类型：[FromQuery]   https://api/search?id=10000
                 [FromRoute]   https://api/search/10000
IQueryable延迟加载: Linq(创建表达式)->IQueryable(延迟执行)->聚合操作(ToList(),执行数据库查询)

2025-11-17
封装资源过滤器（旅游路线查询参数封装TouristRouteResourceParamaters）

2025-11-18
创建旅游路线，创建旅游路线图片

header location返回模式，CreatedAtRoute(返回接口地址的别名，接口参数，接口对象)
return CreatedAtRoute("GetTouristRoutesbyId"
                    , new { touristRouteId = TouristRouteToReturn.Id }
                    , TouristRouteToReturn);

2025-11-19
添加数据验证

属性级别数据验证：using System.ComponentModel.DataAnnotations;
1. DTO模型字段添加字段属性[Required]，[MaxLength(100)]，[Column(TypeName = "decimal(18, 2)")]，[Range(0.0, 1.0)]
2. 自定义校验规则，继承IValidatableObject实现接口函数Validate()

类级别校验：
创建校验类，继承ValidationAttribute，重写IsValid函数，给需要校验的对象添加校验类属性

2025-11-27
合并新建，更新的校验逻辑（继承同一父类，在父类级别再添加校验）

Patch的6种操作：add,remove,replace,move,copy,test
NuGet包：Microsoft.AspNetCore.JsonPatch,
         Microsoft.AspNetCore.Mvc.NewtonsoftJson

patch请求设置:
1. 请求主体 [FromBody] JsonPatchDocument<UpdateTouristRoteDto> jsonPatchDocument
2. jsonPatchDocument.ApplyTo(TouristRouteToPatch);对更新Dto应用jsonPatchDocument
3. patch请求格式：
[
    {
        "op" : "replace",
        "path" : "/title",
        "value" : "welocme to luoma"
    },
    {
        "op" : "replace",
        "path" : "/description",
        "value" : "abcede"
    },
]